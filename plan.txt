BMAD-Aligned MVP Plan for Building 12-Step Recovery App with Claude and Cursor

MVP Plan: Privacy-First 12-Step Recovery Companion App

Overview: This plan outlines an MVP development roadmap for a solo developer building a privacy-focused 12-Step Recovery Companion application. It leverages Claude Code (with structured markdown prompt files for code generation) and Cursor Pro (using the Model Context Protocol, MCP) to accelerate development. The approach is mobile-first (Expo + React Native) with an eventual Next.js web app, so code is structured for reuse and maintainability. An offline-first strategy is emphasized: local storage via SQLite (with encryption) and background sync (Expo TaskManager), ensuring sensitive journaling data stays private and available offline. The Supabase backend (PostgreSQL with Auth and Storage) provides cloud sync, authentication, and sharing capabilities, with strict Row-Level Security for user data. Development is broken into iterative phases using a BMAD (Build-Measure-Analyze-Decide) framework to deliver a lean, testable MVP in 6–8 weeks.

1. Claude.md File Layout by Feature/Domain

To organize Claude Code generation, we create markdown prompt files for each major feature/domain. These will be stored in a dedicated folder (e.g. .claude/) for clarity
composio.dev
. Each file describes the feature’s requirements and target code modules, enabling Claude to generate focused, consistent code. The proposed prompt files include:

AppCoreClaude.md – Sets up core app structure: Expo project initialization, navigation (e.g. React Navigation or Expo Router), theming, and configuration (Supabase client init, context providers). This scaffold ensures a consistent architecture across features.

OnboardingClaude.md – Bootstraps user onboarding flows, including Sign Up/Sign In screens (email/pass via Supabase Auth) and initial user profile setup. It ensures integration with Supabase Auth (using provided SDK – Supabase handles heavy lifting for auth
composio.dev
) and stores any initial data like sobriety start date. Also includes SecureStore usage for sensitive tokens (Expo SecureStore encrypts data on device
docs.expo.dev
).

JournalingClaude.md – Implements the encrypted personal journal feature. This includes UI for creating/viewing journal entries and logic to encrypt entries client-side (using a symmetric key stored securely in SecureStore). Entries are saved to a local SQLite database for offline access. (Expo’s SQLite persists data across app restarts
docs.expo.dev
, and supports full DB encryption via SQLCipher
docs.expo.dev
 for privacy.) This prompt also covers optional cloud sync: when online, encrypted entries can be backed up to Supabase (Postgres table or Storage) with Row-Level Security so only the user can access their data
supabase.com
.

StepWorkClaude.md – Provides UI and data models for working through the 12 steps. This includes guided forms or notes for steps (e.g. Step 4 inventory, Step 10 daily check-in). Data is stored offline (SQLite) and synced to Supabase when available. The prompt ensures step data is structured (e.g. tables for inventories or reflections) and potentially reused on web. (Sensitive step work is treated like journals – encrypted at rest for privacy).

SponsorClaude.md – Manages sponsor–sponsee connections and sharing. Implements a way for a user to link with a sponsor (e.g. via an invite code or email lookup) and to share selected journal entries or step progress securely. The Claude prompt will generate UI for invite/accept flows and underlying logic: e.g. a Supabase table for sponsorship relations and methods to mark an entry as shared. Privacy is paramount: sharing is opt-in and limited. Supabase RLS policies ensure only the sponsor designated by the user can read shared entries
supabase.com
 (e.g. policy allowing a sponsor to SELECT an entry if entry.owner_id == sponsor.user_id OR entry.shared_with == sponsor.user_id). This file will also handle any encryption keys exchange or sharing mechanism (for MVP, possibly a simpler approach like server-side encryption with sponsor’s public key, if time permits).

NotificationsClaude.md – Sets up local notifications and geofencing features. This prompt covers scheduling daily reminders (e.g. for journaling, gratitude, or step check-ins) using Expo Notifications API, and implementing geofenced triggers around meeting locations. It will define a background task with Expo’s TaskManager for geofencing
docs.expo.dev
 – e.g. when the user enters or leaves a saved meeting location region, schedule a prompt to log a meeting reflection. (We’ll ensure to define the task at the app’s global scope as required by Expo
docs.expo.dev
.) Platform nuances are considered: iOS can auto-relaunch the app for geofence events while Android cannot
docs.expo.dev
, so the code will gracefully handle missed Android events (e.g. require app open for final logging). NotificationsClaude.md will generate code for requesting runtime location permissions and scheduling notifications accordingly.

ChallengesClaude.md – Implements milestone tracking (sobriety streak counter) and recovery challenges. This includes logic to record the sobriety start date and compute the current sober days streak (with celebratory notifications on milestones). It also can include a simple challenge system (e.g. “30 meetings in 30 days” or daily journaling streaks), tracking progress in local state or database. The prompt will generate UI components for displaying milestones (perhaps a progress badge or token earned) and for listing active challenges. This feature ties into notifications (e.g. remind user about today’s challenge task) and uses shared utilities (date calculations, etc.), which should be placed in a common module for reuse in the web app.

Each markdown prompt instructs Claude to output code in the appropriate target files (using Cursor’s MCP to direct the output into our project structure). By separating prompts by domain, we encourage modular code generation and consistent coding patterns per feature. (All prompt files reside under a .claude directory for organization, and Claude’s “skills” feature could be used to maintain consistency across them
composio.dev
.) This structure will make it easier to maintain and later extend or reuse code for the Next.js web implementation.

2. MCP Folder Layout and Repo Structure

To maximize code reuse and maintainability, we adopt a structured repository layout. A monorepo approach is suggested, housing the Expo app and (future) Next.js app side by side, with shared packages for common code. For example
docs.expo.dev
:

repo-root/
├── apps/
│   ├── mobile/        # Expo React Native app (MVP focus)
│   └── web/           # Next.js app (to be implemented later; placeholder)
├── packages/
│   ├── shared/        # Shared logic (models, utilities, hooks) usable by both apps
│   ├── api/           # (Optional) API client or abstractions (e.g. wrappers for Supabase calls)
│   └── ui/            # (Optional) Cross-platform UI components (if using RN web or a design system)
├── .claude/           # Claude prompt files (e.g., OnboardingClaude.md, etc.), organized by feature
├── package.json       # Workspaces configuration for monorepo:contentReference[oaicite:12]{index=12}
└── ...                # Other config files (tsconfig, metro.config, etc.)


Mobile app structure (Expo): Inside the Expo app (e.g. apps/mobile), use a feature-based organization for clarity. For instance:

src/features/auth/ – screens and components for onboarding & authentication (login, signup forms).

src/features/journal/ – journal screens, components (entry list, entry editor), and local storage logic (SQLite models, SecureStore key handling).

src/features/steps/ – step work screens (maybe sub-screens per step or a unified component with step content), data handlers for step inventories.

src/features/sponsor/ – sponsor connection UI (invite code entry, sponsor info) and logic for sharing entries.

src/features/notifications/ – background task definitions (geofence handler), notification scheduling utilities.

src/features/challenges/ – components for milestones (sobriety counter display) and challenge tracking UI.

src/components/ – common reusable UI components (e.g. form inputs, buttons, or a <JournalEntryCard> component).

src/utils/ or src/lib/ – utility modules (e.g. encryption helper, date utilities, Supabase client initialization, network status monitor for sync).

src/App.tsx – entry point setting up Navigation (stack/tab navigators linking feature screens) and global providers (theme, auth context, SQLite db context, etc.).

Web app structure (Next.js): The Next.js app (in apps/web) will be initialized later. We plan its structure to mirror the feature domains of mobile for consistency. Shared logic from packages/shared can be imported to handle data and business rules identically. The UI layer will differ (web pages vs mobile screens), but using a library like React Native Web or a component library could allow sharing some UI components as well. At MVP stage, we won’t implement the web, but we keep the mobile code platform-agnostic where possible (e.g. writing logic in plain TypeScript modules and minimizing direct Expo-specific calls in the core business logic).

 

MCP integration: Cursor Pro’s MCP server will be configured to allow Claude to read/write files in the repo. We ensure the Claude.md prompt files reference the correct target paths (e.g. generating code in apps/mobile/src/features/...). Each prompt can specify multiple file outputs if needed – for example, JournalingClaude.md might instruct Claude to create a JournalScreen.tsx, a journalStorage.ts (SQLite helper), and so on. By matching the prompt file organization with the repo’s folder structure, we make it straightforward for Claude (and the developer) to navigate the codebase. The monorepo setup (with apps/ and packages/) is supported by Expo and will be configured via Yarn/NPM workspaces
docs.expo.dev
, so both mobile and web can share code easily.

 

Overall, this structure prioritizes clarity (each feature in its own module), privacy (sensitive logic encapsulated, e.g., encryption in journal utils), and extensibility (ready to plug in a Next.js front-end, and even additional features, without major refactor).

3. Iterative BMAD Roadmap by Phase

Development is divided into phases, each following a Build-Measure-Analyze-Decide cycle. This ensures lean, testable increments and the ability to pivot or polish as needed. Below is the phase-wise plan:

Phase 0: Setup & Project Scaffolding

Build: Initialize the monorepo and Expo project. Use ProjectSetupClaude.md (or AppCoreClaude.md) to scaffold the Expo mobile app with minimal functionality. This includes creating a new Expo app (TypeScript), setting up navigation (e.g. a basic tab navigator with placeholder screens for Journal, Steps, etc.), and configuring Supabase. Supabase setup involves installing the JS client and wiring environment keys (stored securely). Also, initialize the SQLite database (using expo-sqlite) and create a basic schema (tables for journals, steps, etc. can be placeholders for now). Configure expo to allow background tasks (update app.json with required permissions for location and notifications). MCP targets: The entire base Expo app structure (apps/mobile) is generated here. We also create the .claude directory and stub out feature prompt files (empty or with basic comments) for upcoming phases.

Measure: Verify the scaffold: the mobile app should compile and run on a device/emulator without errors. Check that navigation works (tabs or stacks show placeholder screens), and that Supabase is reachable (e.g. calling a supabase.auth.getSession() returns no session but proves config is loaded). Confirm the SQLite database opens without issues. Ensure the basic repo structure is recognized by tools (workspace builds, etc.). No actual user functionality yet, but the skeleton should be solid.

Analyze: Evaluate project architecture choices. Is the navigation structure suitable for adding features? (E.g. perhaps we used a Tab navigator: will that scale to include all main features? If not, consider switching to a drawer or nested navigators.) Check code organization – are directories set for features, and is shared code (like types, theme) in a logical place? From a privacy perspective, ensure no sensitive data is exposed in config (Supabase anon key is okay to embed, but confirm .env handling). Performance at this stage is fine (virtually no content), but verify that adding heavy features (like encryption libraries, etc.) is feasible (e.g. if using SQLCipher, did we plan for a dev build? Yes – if not, note it now).

Decide: If the app scaffold runs well, proceed to Phase 1. If there were setup issues (say, navigation library conflicts or monorepo config problems), address them now (even if it means adjusting the structure). Decision checkpoints: ensure we have the latest Expo SDK that supports needed APIs (e.g. background tasks) – upgrade if not. Also decide on any libraries to bring in early (for state mgmt or forms) so Phase 1 can include them. Once decided, move to building core auth.

Phase 1: Core Architecture & User Auth

Build: Implement the core user authentication and app architecture improvements. Use OnboardingClaude.md to generate the onboarding flow: signup & login screens (with form validation) that interact with Supabase Auth (email/password sign-up, login, password reset if needed). Include an onboarding step for the user to input initial profile info (especially their sobriety start date for milestone tracking). Set up a basic Auth context or state (so that other parts of the app know the logged-in user). Also, establish secure token storage: when the user logs in, store the refresh token or session in SecureStore
docs.expo.dev
 to keep the user signed in (Supabase’s client can persist session, but we ensure it’s device-secure). This phase also refines architecture: for example, protect inner screens behind an Auth gate (if not logged in, show onboarding; if logged in, show main app). Claude.md files: OnboardingClaude.md (UI and logic), plus possibly an AuthUtilClaude.md for Supabase integration (functions for signIn, signOut, etc.). We ensure that any navigation flows (e.g. moving from login to main tabs) are implemented. MCP targets: primarily the features/auth/ screens and any context in shared/ for user state.

Measure: Manually test the auth flows on a device. Sign up a new user (ensure it creates an account in Supabase). Log in with the new account (the app should navigate to main content). Test log-out functionality (if included) returns to login screen. Check that the sobriety date or profile info is saved (perhaps in a “profile” table in Supabase or local storage) and persists on re-login. Also test edge cases: entering an incorrect password (Supabase should return an error, ensure the UI displays it), or network offline during login (the app should handle it gracefully, maybe queue the login or show “offline, cannot authenticate” message). Confirm SecureStore indeed stores tokens (we can log a successful retrieval of a token after login – without printing the token itself). Ensure no sensitive info is logged or leaked.

Analyze: Evaluate user experience and privacy at this stage. From a behavior perspective, consider how a recovering user will interact: the sign-up should be simple and reassuring (maybe minimal personal info, given privacy). Are we allowing anonymous usage? (Perhaps not, since sharing and sync require an account; but if privacy is a concern, maybe allow offline-only mode without sign-up – decide if that’s needed now or later). Analyze performance: Supabase auth calls are lightweight; just ensure we are not making redundant calls. On the privacy side, verify that we are not storing plain-text credentials anywhere. Supabase Auth will handle passwords, but on our side, we ensure things like the email or any personal data are stored securely. Also consider using biometric login in future (not MVP, but mention if relevant for deciding future steps). From a code perspective, analyze if the auth code is easily reusable for web (likely yes: Supabase JS works in browser too; the form logic can be reused).

Decide: If auth is working smoothly, the next step is enabling core app features (journaling & steps). Decide if any adjustments are needed before proceeding: e.g., if sign-up is slow, plan to add a loading indicator; if offline login is desired, consider a strategy (perhaps allow using last logged-in account offline with cached credentials – could be complex, so maybe defer). Also decide if any testing is needed now (maybe write a couple of unit tests for the auth functions using Claude, or do that in Phase 5). Ensure the groundwork (navigation, context, user profile) is solid, then move on to Phase 2.

Phase 2: Journaling & Step Work

Build: This phase delivers the core recovery tools: personal journaling (with encryption and offline sync) and step work guides. Use JournalingClaude.md to implement the Journal feature. This includes a Journal screen listing past entries and a form to create new entries (title + content, maybe mood or tags). Encryption: before saving an entry, encrypt the content (and any sensitive fields) using a key. For MVP, a symmetric key can be generated on first login and stored in SecureStore
docs.expo.dev
. We can use a library (or Expo’s Crypto) for AES encryption. The encrypted text is then saved in SQLite (we can also encrypt at DB level using SQLCipher for double safety
docs.expo.dev
). If the device is online, also insert the encrypted entry into a Supabase journal_entries table (with user_id foreign key and RLS so only that user can select it
supabase.com
). Implement a basic sync mechanism: e.g., on app start or pull-to-refresh, fetch any new entries from Supabase to sync to local (in case the user uses multiple devices or the upcoming web app). Similarly, unsynced local entries get sent to Supabase when connection is available
medium.com
medium.com
. Use Expo’s NetInfo or a background task to trigger sync attempts periodically. Next, use StepWorkClaude.md to implement Step Work screens. Possibly have a screen per step or a generic template that loads step-specific content/questions. At minimum, include Step 4 inventory (allow user to list resentments/fears in a structured way), and Step 10 daily review (maybe a nightly questionnaire). Data from these can be stored locally (e.g. a separate SQLite table for each step’s entries or a unified step_entries table with a step number column). Sync step data to Supabase as well for backup, applying encryption if it contains sensitive text. The UI should allow the user to mark steps as completed and revisit entries. Claude prompt outputs: likely multiple files – e.g., JournalScreen.tsx, NewEntryScreen.tsx (if separate), journalSlice.ts or context for state, and similar for Steps (maybe StepScreens.tsx and some data model file). We also ensure to update navigation to include these (Journal might be one tab, Step Work another tab).

Measure: Test journaling thoroughly. Creating an entry: Does it appear in the list immediately? After app restart, does it persist (from SQLite)? To verify encryption, one might check the SQLite file or console-log the stored data – it should be gibberish/encrypted, not plain text. Also verify the encryption key is not printed or transmitted. Check that when online, the entry is indeed added to Supabase (using Supabase dashboard or logs) and that fetching it respects RLS (try to read it as another user – should be disallowed). Test offline mode: turn off internet, create a journal entry, close and reopen app – the entry should still be there (from local DB). Then go online and ensure the entry syncs to server (maybe add a visual indicator for unsynced entries or just observe via the DB). For step work, input sample data for a step (e.g. fill a Step 4 form) and ensure it’s saved and can be edited later. If step content is pre-defined (like questions or prompts), ensure those are loaded correctly. Measure the UI/UX: is it responsive when entries grow? (Add 20+ entries to see list performance – likely fine, but consider using FlatList properly.) Check any search or filtering if implemented (maybe not in MVP).

Analyze: Analyze how users will use these features. User behavior: journaling frequency might be daily or ad-hoc – our design should make it quick to add an entry (consider adding a quick-add widget or reminder – maybe in Phase 4’s notifications). Step work might be less frequent but more intense – ensure the app doesn’t overwhelm (maybe break long inventories into smaller chunks – perhaps a future improvement). Privacy analysis: The encrypted journal is a key selling point – double-check that all sensitive fields are indeed encrypted before leaving the device. Consider threat models: if someone gets the device or the raw DB, are entries safe? (They should be, due to encryption and/or SQLCipher DB). How is the encryption key protected? (SecureStore is device-secure, but maybe add an app passcode or biometric option in a later phase for extra safety). Also consider that step answers can be just as sensitive as journal entries – ensure they get similar protection. Performance: The encryption/decryption overhead for each entry – is it noticeable? Likely negligible for text sizes here, but if the app later allows images or large data, plan accordingly (maybe use Supabase Storage for images, not in MVP). The SQLite operations and sync should also be analyzed: make sure we mark entries with an “unsynced” flag and only sync those
medium.com
medium.com
 to avoid unnecessary writes. For large number of entries, consider pagination or limits for both local and remote (not urgent now, but keep in mind). Also, analyze code maintainability: do we see any duplicate logic between journaling and steps? If yes, consider refactoring into shared utilities (e.g. a generic “Entry” model with type = journal or step).

Decide: Decide on any adjustments before moving on. If journaling encryption isn’t fully implemented (maybe Claude struggled with crypto details), decide whether to spend time to fix it now (encryption is a core privacy feature, so likely yes – even if we need to use a known library or write a wrapper). If step work feature is too basic, we might decide to add one more guided step (like Step 11 meditation journal) if time permits, or leave it for later polish. Also, if the sync mechanism is not reliable yet, decide if MVP can launch without full sync (perhaps okay if we emphasize offline-first single-device usage initially). Given the time, it might be acceptable to require internet for sponsor sharing only, and do background sync for journals as a “nice-to-have.” Prioritize any critical fixes (e.g. data loss on logout – we should decide if journal entries are wiped on logout or kept encrypted for when user logs back in; possibly tie them to account). Once satisfied, progress to enabling sponsor connectivity in Phase 3.

Phase 3: Sponsor Connection & Sharing

Build: Implement the features for connecting with a sponsor and sharing progress with them. Using SponsorClaude.md, generate the code to allow a user to invite a sponsor or become a sponsor for someone else. Likely, we introduce a simple sharing model: e.g., each user profile has a “sponsorCode” or uses their email to connect. Build a screen where a user can enter someone’s code/email to invite them as their sponsor. On the backend, create a Supabase table sponsors or a relation table linking two user IDs (sponsee -> sponsor). Also define a status (pending, accepted). Claude can help generate a function to handle the invite: write a row in the table and perhaps send a notification (out of scope for now unless using email). The sponsor user, when logging in, should see a “request” which they can accept. Build UI for viewing and accepting sponsorship requests. Once two accounts are linked as sponsor-sponsee, enable sharing: decide what can be shared in MVP – presumably journal entries and/or step work entries. Implement a mechanism for a sponsee to mark specific entries as shared with sponsor. For example, add a boolean or a separate table shared_entries (entry_id, sponsor_id). When a user marks an entry to share, if online, the app writes an entry in that table (or sets a flag on the entry row) to give sponsor read access. Supabase RLS policies will be crucial: e.g., allow a user to read another user’s journal entry only if there’s a shared_entries record linking them
supabase.com
. Use Claude to generate a query or API call that the sponsor’s app can use to fetch those shared entries. In the UI, the sponsor should have a screen listing sponsee’s shared content (maybe under a “Sponsee” section). Implement basic navigation for sponsors (perhaps a toggle if the logged-in user is a sponsor, or a combined view). Additionally, allow the sponsor to send feedback on an entry (could be as simple as a text comment or even just an acknowledgment; due to time, maybe just viewing is enough, but we can include a comment feature if feasible). The Claude.md prompts will generate components like InviteSponsorScreen.tsx, SponsorRequestsScreen.tsx, and possibly modify the Journal view to add a “Share with Sponsor” toggle or button on entries. Also, update context/state to handle sponsorship info (maybe store sponsorUserId and sponseeUserId if applicable, to know role).

Measure: Create two test accounts to simulate sponsor and sponsee. On Account A, go to invite sponsor and use Account B’s identifier. On Account B, ensure a notification or at least an entry appears (perhaps refresh to see “You have a request from A”). Accept the request on B. Now on A (sponsee side), verify the app shows B as connected (maybe display sponsor’s name on a “Sponsor” screen). Test sharing: on A’s journal, mark an entry as shared. On B’s device, see if that entry now is visible. The entry content should be decrypted for A; for B, since it’s encrypted with A’s key, how does B see it? (If we implemented a secure share, maybe A’s client encrypted it with a shared key or we chose to trust server? For MVP, we might have stored the entry plaintext in a protected function or used a symmetric key known to both – if not, perhaps we temporarily compromise and store a second copy encrypted with sponsor’s key). If a simple approach was used (like no end-to-end encryption for shared, just rely on supabase security), then B can fetch the plaintext from the database. Ensure this works: B can read the entry, A’s privacy is still maintained from others. Test revocation: if A un-shares or removes sponsor, does B lose access? (Maybe not implemented in MVP, but consider if deletion of shared record happens on unshare). Also test that sponsor B cannot see entries that weren’t explicitly shared. Try edge cases: what if A shares then goes offline – B should still see it if B is online (since it’s in cloud). If both offline and come online later, make sure the share syncs up. Measure UI clarity: is it obvious to the user how to connect and what sharing does? Are there confirmations to prevent accidental oversharing? (Maybe add a confirmation dialog when sharing an entry, not critical but good UX).

Analyze: Consider the user experience and trust: In 12-step culture, sponsor relationships are built on trust and anonymity. Our app must reflect that. Analyze if the privacy-first promise holds: are we storing any content on the cloud unencrypted? If we did not implement full end-to-end encryption for sharing due to time, note this as a privacy trade-off and plan to fix later (maybe by exchanging encryption keys during the invite step for true E2EE). Check compliance with anonymity: maybe users prefer using a code rather than email to preserve anonymity (we used codes possibly). If emails are used, ensure we do not expose email addresses publicly anywhere in the app. Performance: the sponsor sharing is relatively low-volume (just textual data), so performance is fine. But consider scalability if the user or sponsor has multiple sponsees – our UI is basic and probably just handles one-to-one sponsorship. Mark this for potential enhancement (like supporting multiple sponsees per sponsor). Also analyze failure cases: if sponsor never accepts, do we allow re-inviting or cancel? Not critical for MVP, but think about cleaning up pending invites maybe later. Code maintainability: ensure the sharing logic is well encapsulated (perhaps in shared/ as it will be used in web too).

Decide: If sponsor linking and sharing works in basic form, move on. Decide on improvements either now or post-MVP: for example, do we need a chat or messaging between sponsor and sponsee? It’s a common feature (some apps have chat
12steptoolkit.com
) but might be out-of-scope for MVP given time. Likely decide to defer messaging, focusing on the one-way sharing with optional comment. Also decide if any quick security enhancements should be added now (like if plaintext sharing was used, maybe add a warning in privacy policy, and schedule adding encryption in future). If the sharing flow is confusing, plan a small UX tweak (maybe a tutorial or better labels, could be done in Phase 5 polish). With sponsor features in place, proceed to Phase 4 to implement notifications and geolocation features.

Phase 4: Notifications, Geofencing & Streaks

Build: Add supportive features that increase engagement: local notifications (including scheduled reminders and geofence-based prompts), geolocation awareness for meetings, and tracking sobriety streaks/challenges. Using NotificationsClaude.md, implement push/local notifications. For daily reminders: decide on a default schedule (e.g. every day at 9pm prompt “How was your day? Write your Step 10 reflection.”). Use Expo Notifications API to schedule these notifications locally
docs.expo.dev
 (no server needed for scheduled or repeating local notifications). Also implement notification permissions request on first use. For geofencing: allow the user to save a “Meeting location” (could be a simple screen where they enter an address or use current location to set a geofence). Use Expo Location + TaskManager to register a geofencing task for that coordinate
docs.expo.dev
. For MVP, perhaps limit to one geofence (the user’s home group meeting). The TaskManager’s background task, when triggered (user enters or exits region), will schedule or immediately present a notification like “You’re near [Meeting name]. Meeting time soon – stay strong!” or after leaving: “Great job attending your meeting! Log a reflection.” Ensure to handle platform differences (iOS will revive the app on geofence, Android requires app running to catch it
docs.expo.dev
; document this limitation in-app if needed). Next, implement streak tracking in the ChallengesClaude.md prompt (or integrated here): this includes a sobriety date tracker that calculates days sober (difference between today and the start date stored in profile). Display this prominently (e.g. on a Home screen or Profile screen, “You have been sober for X days”). Possibly award a milestone token for certain days (30, 60, 90, etc.). Also implement a simple streak challenge for journaling or meetings: e.g., count consecutive days of journal entries. The code can check the dates of journal entries to compute the current streak and longest streak. Similarly, for meetings, if the user marks a meeting attended (maybe via a button when at geofence), count consecutive days or weeks of meetings. These features mostly involve calculations and local notifications to nudge the user. In code, create utility functions for streak calculation and schedule milestone notifications (e.g. on day 30, schedule a congratulatory notification). If time permits, integrate these features into the UI: perhaps a “Dashboard” screen that shows days sober, current challenges, and next milestone. Claude outputs: new files like notifications/taskDefinitions.ts (for TaskManager defineTask for geofence), notifications/schedule.ts (helper to schedule daily reminders), and UI components for streak display (could be part of an existing screen or a new ProgressScreen.tsx). Also update app.json/Info.plist for background location usage descriptions (Claude could generate the snippet for this).

Measure: Testing these features can be tricky but important. Notifications: schedule a test notification for 1 minute in the future – does it fire when the app is backgrounded? Does tapping it open the app (and maybe navigate to journal)? Test daily schedule by changing device time or trusting a short interval test. Geofencing: in simulator, we might use debugging to simulate location. Alternatively, set a geofence around a location and physically (or via simulator controls) trigger an entry. Validate the TaskManager task runs: maybe log something or update state when triggered. Ensure that the app requests “Always” location permission (on iOS, user might grant “Allow Once” or “While in Use” – our task won’t run in background unless “Always” is granted
docs.expo.dev
). The code should handle permission not granted (maybe disable geofence feature or show a prompt to change settings). Streaks: Set the profile start date to some past date and verify the day count is correct. Change the date to test edge cases (e.g. if someone relapses and resets date – out of scope now, but our logic should handle updating the start date resets streak). For journaling streak, create entries on consecutive days (you can simulate by altering device date or just code a function to compute based on timestamps) and verify the streak count. Measure the usability: do users get the right amount of notifications? (Not too many to be annoying, but enough to be helpful). Also check battery impact: geofencing a single region is low overhead, but ensure we don’t poll location unnecessarily. Expo’s API should handle it efficiently; still, verify that the location background mode is only on if user enabled the feature. If the user didn’t opt for geofence, we shouldn’t run that task.

Analyze: Analyze user engagement and privacy impacts. Behavior: The notifications and streak features aim to encourage daily engagement. Are we aligning with recovery principles (e.g., daily inventory, regular meeting attendance)? It seems so. But ensure flexibility: some users might find constant reminders triggering, so we might later add settings to toggle these. Privacy: We must be careful with location data – since this is privacy-first, we likely do not send location to our server at all. We only use it on-device for geofence, which is good. Confirm that we aren’t logging GPS coordinates or storing them in Supabase (unless absolutely needed; better to store just a name of location and coordinate locally). Also, any notification content should be discrete – e.g., notification text should be mindful (maybe avoid explicitly mentioning “AA” or such if user hasn’t opted in, to not expose them if someone sees their phone). Performance analysis: notifications scheduling is light; geofencing has limits (100 geofences on Android, 20 on iOS
docs.expo.dev
 – we are within that). Check that background tasks don’t eat memory or cause app crashes – perhaps schedule a background fetch (Expo BackgroundFetch) to sync data periodically if needed (not critical for MVP, but noted). Codewise, ensure the new features are decoupled (notification logic could be reused on web partially, though web might not support geofence or local notify in same way – likely web will use different approach like email reminders).

Decide: Decide if the app is feature-complete enough to consider polishing. If some notification or geofence piece is not reliable, consider deferring it or simplifying: e.g., if geofencing is too unpredictable on Android due to background restrictions, we might decide to replace that with time-based reminders for meetings (e.g. user sets meeting time and gets a reminder then, rather than location-based – less cool but more reliable). Or we note it as a known limitation. Also decide on tuning notification content/frequency based on test feeling – we can adjust times or allow customization in future. At this point, we have all core features built. If timeline is okay, proceed to Phase 5 for polish and testing. If we’re behind, decide which features can be trimmed or need to be cut for MVP (for instance, maybe challenges could be dropped if incomplete, or geofencing removed if not working, etc., to ensure a stable core app). The decisions here will finalize the MVP scope that we’ll polish in the next phase.

Phase 5: Polish (Accessibility, UX, Testing)

Build: This phase is about refining and fixing rather than adding major features. Focus on UX improvements: ensure the app feels cohesive and easy to use. For example, add loading spinners or feedback where needed (login, data sync operations). Improve form validations (no empty journal entries, etc.). Implement basic accessibility: test with screen readers (all buttons and inputs should have accessible labels), ensure color choices are accessible (contrast), and support dynamic font sizing if possible. Also, address any UI consistency issues (margins, fonts). If not already, remove any console.log that might leak sensitive info. Testing: Write automated tests for critical logic if time permits. For instance, use Claude to generate some unit tests (maybe via a TestsClaude.md prompt). Focus on testing encryption/decryption functions (given an input, after encrypt then decrypt, do we get original back?), and maybe test the logic that computes streaks or filters shared entries. If end-to-end tests are possible (perhaps using Detox or Cypress for RN), that might be beyond MVP scope, but we can do a thorough manual test run on both Android and iOS devices/emulators. Also, set up analytics or error tracking if desired (though privacy-first might mean we keep tracking minimal – maybe just Sentry for crashes without personal data). Code cleanup: use a linter and formatter to standardize code style. Remove dead code and add comments where needed for clarity. Since maintainability is key, ensure each module has a brief README or doc string (maybe done earlier, but good to finalize now).

Measure: Conduct a final MVP acceptance test: simulate a real user scenario end-to-end. E.g., “User signs up, writes a journal entry, marks it shared to sponsor, gets a notification next day, etc.” Does everything work together without crashes or confusion? Test the app on low connectivity (airplane mode for offline then online transitions). Test on both major platforms for any device-specific issues (particularly iOS background behavior and Android permissions flows). Check memory usage if possible (no obvious leaks – open and close screens to see if performance stays okay). Validate that all text is visible in both light/dark mode (if we support dark mode), and that small devices or large font settings don’t break layouts. For accessibility, measure using any available tools (like iOS Accessibility Inspector) if available, or just ensure navigability via keyboard or screen reader. If automated tests were written, run them and ensure they pass. Measure code coverage (optional). Also measure app size – including all the libraries, is it reasonable? (Expo apps can be a bit large, but ensure it’s within reason for MVP). If anything fails these tests, fix them now.

Analyze: Analyze if the MVP meets the project goals. We examine if the app is privacy-first in practice: All personal data is either kept local or encrypted if synced (journals and steps encrypted, only minimal profile info in plain like email). Supabase RLS ensures even if data is in cloud, others can’t access it without permission. Check that we didn’t accidentally include any analytics SDK or Expo EAS config that might send data (if so, remove or document it). User experience analysis: Is the app intuitive for our target users (people in recovery, who may not be tech-savvy)? Perhaps conduct a quick usability session with a friend (if possible) to gather impressions. Identify any final must-fix UX issues (like “I couldn’t find where to accept sponsor request” or “Notification text was confusing”). Analyze if the app is maintainable for the solo developer going forward: we have modular code, we can extend it. The upcoming web app can reuse the shared logic – verify that our abstractions (in packages/shared) actually contain useful code (like encryption utils, Supabase queries) that can prevent duplicate work in Next.js. If not, consider extracting some now or note it for later. Also, consider performance in the long run: if this scales to many users or lots of data, are there any risks? (Perhaps the sync strategy might need revisiting with real backend functions for conflict resolution – not a focus now, but good to keep in mind).

Decide: At this point, decide if the product is ready to release as an MVP or if another iteration is needed. If critical issues were found in testing (e.g., data loss, crash in a common scenario), definitely fix and potentially do a quick re-test cycle. If only minor improvements are left, prioritize what to do now vs post-launch. For example, maybe decide to launch without a certain nice-to-have feature turned on if it’s not stable (feature flag it off). Also make decisions about launch preparation: ensure we have app store metadata ready, but that’s outside development scope. From a development perspective, decide on post-MVP roadmap: e.g., Next.js web app – likely the next big step. We should plan how to reuse as much as possible (maybe create a new Next.js project and bring in shared package to start implementing web UI in parallel). Or decide on any tech changes for web (maybe use Next.js with React Native Web to literally reuse components – to be researched). Additionally, decide if any additional privacy measures should be added before release: perhaps a passcode lock for the app, or a prompt for a PIN on launch (if time permits, maybe slip a simple version in now using SecureStore to save a PIN – if not, plan it for later). Once decisions are made and the app is judged “MVP complete,” the development phase ends. The next steps would involve gathering user feedback and iterating, but those are beyond this initial MVP scope.

Conclusion: By following this phased BMAD approach, our solo developer can confidently build a functional MVP within 6–8 weeks. Each phase delivers incremental value – from a solid foundation to core recovery tools, support network integration, and engagement features – all while keeping privacy and clarity at the forefront. The codebase is structured for growth, allowing a future Next.js web implementation to plug in with minimal friction. With this plan, the developer can focus on one piece at a time, measure success, and make informed decisions at each juncture, resulting in a high-quality, privacy-first 12-Step Companion app.