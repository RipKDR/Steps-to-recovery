/**
 * Database Utilities
 * 
 * Provides database initialization, schema management, and migration utilities.
 * Works with both SQLite (mobile) and IndexedDB (web) via StorageAdapter abstraction.
 * 
 * **Features**:
 * - Versioned schema migrations
 * - Idempotent initialization (safe to call multiple times)
 * - Concurrent initialization protection
 * - Automatic index creation for performance
 * 
 * @module utils/database
 */

import type { StorageAdapter } from '../adapters/storage';
import { logger } from './logger';

/**
 * Guard against duplicate/concurrent initialization
 * 
 * Common in React StrictMode (dev) and fast refresh scenarios.
 * Uses database name instead of object identity for more reliable duplicate detection.
 */
const initializedDatabases = new Set<string>();
const initPromises = new Map<string, Promise<void>>();

/**
 * Current database schema version
 * 
 * Increment this when adding new migrations. Migrations are applied
 * sequentially from the current version to this target version.
 */
const CURRENT_SCHEMA_VERSION = 6;

/**
 * Initialize database with schema for offline-first storage
 * 
 * Creates all required tables, indexes, and applies pending migrations.
 * Safe to call multiple times (idempotent).
 * 
 * **Tables Created**:
 * - user_profile - User metadata
 * - journal_entries - Encrypted journal entries
 * - daily_checkins - Morning/evening check-ins
 * - step_work - 12-step work progress
 * - achievements - User achievements
 * - sync_queue - Pending cloud sync operations
 * - cached_meetings - Public meeting data cache
 * - favorite_meetings - User's favorite meetings
 * 
 * @param db - Storage adapter instance (SQLite or IndexedDB)
 * @returns Promise that resolves when initialization is complete
 * @throws Error if initialization fails critically
 * @example
 * ```ts
 * const db = await getDatabase();
 * await initDatabase(db);
 * // Database is ready to use
 * ```
 */
export async function initDatabase(db: StorageAdapter): Promise<void> {
  const dbName = db.getDatabaseName();
  if (initializedDatabases.has(dbName)) {
    logger.info('Database already initialized, skipping', { dbName });
    return;
  }

  const existing = initPromises.get(dbName);
  if (existing) return existing;

  const initPromise = (async () => {
    logger.info('Initializing database', { dbName });
    // Some Android sqlite bindings can throw opaque native errors (e.g. NPE) when executing
    // very large multi-statement strings via execAsync. Execute pragmas and schema statements
    // in smaller chunks to be more reliable.

    // Pragmas
    try {
      await db.execAsync('PRAGMA journal_mode = WAL;');
    } catch {
      // Some platforms may not support WAL; ignore and continue.
    }
    try {
      await db.execAsync('PRAGMA busy_timeout = 5000;');
    } catch {
      // Ignore; best-effort.
    }
    try {
      await db.execAsync('PRAGMA foreign_keys = ON;');
    } catch {
      // Ignore; best-effort.
    }

    const statements: string[] = [
      `CREATE TABLE IF NOT EXISTS user_profile (
        id TEXT PRIMARY KEY,
        encrypted_email TEXT NOT NULL,
        sobriety_start_date TEXT NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );`,
      `CREATE TABLE IF NOT EXISTS journal_entries (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        encrypted_title TEXT,
        encrypted_body TEXT NOT NULL,
        encrypted_mood TEXT,
        encrypted_craving TEXT,
        encrypted_tags TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        sync_status TEXT DEFAULT 'pending',
        supabase_id TEXT,
        FOREIGN KEY (user_id) REFERENCES user_profile(id)
      );`,
      `CREATE TABLE IF NOT EXISTS daily_checkins (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        check_in_type TEXT NOT NULL CHECK(check_in_type IN ('morning','evening')),
        check_in_date TEXT NOT NULL,
        encrypted_intention TEXT,
        encrypted_reflection TEXT,
        encrypted_mood TEXT,
        encrypted_craving TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL DEFAULT (datetime('now')),
        sync_status TEXT DEFAULT 'pending',
        supabase_id TEXT,
        FOREIGN KEY (user_id) REFERENCES user_profile(id)
      );`,
      `CREATE TABLE IF NOT EXISTS step_work (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        step_number INTEGER NOT NULL CHECK(step_number >= 1 AND step_number <= 12),
        question_number INTEGER NOT NULL,
        encrypted_answer TEXT,
        is_complete INTEGER DEFAULT 0,
        completed_at TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        sync_status TEXT DEFAULT 'pending',
        supabase_id TEXT,
        UNIQUE(user_id, step_number, question_number),
        FOREIGN KEY (user_id) REFERENCES user_profile(id)
      );`,
      `CREATE TABLE IF NOT EXISTS achievements (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        achievement_key TEXT NOT NULL,
        achievement_type TEXT NOT NULL,
        earned_at TEXT NOT NULL,
        is_viewed INTEGER DEFAULT 0,
        UNIQUE(user_id, achievement_key),
        FOREIGN KEY (user_id) REFERENCES user_profile(id)
      );`,
      `CREATE TABLE IF NOT EXISTS sync_queue (
        id TEXT PRIMARY KEY,
        table_name TEXT NOT NULL,
        record_id TEXT NOT NULL,
        operation TEXT NOT NULL CHECK(operation IN ('insert','update','delete')),
        supabase_id TEXT,
        created_at TEXT NOT NULL,
        retry_count INTEGER DEFAULT 0,
        last_error TEXT,
        failed_at TEXT,
        UNIQUE(table_name, record_id, operation)
      );`,
      `CREATE TABLE IF NOT EXISTS daily_readings (
        id TEXT PRIMARY KEY,
        day_of_year INTEGER NOT NULL UNIQUE CHECK(day_of_year >= 1 AND day_of_year <= 366),
        month INTEGER NOT NULL CHECK(month >= 1 AND month <= 12),
        day INTEGER NOT NULL CHECK(day >= 1 AND day <= 31),
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        source TEXT NOT NULL,
        reflection_prompt TEXT NOT NULL,
        created_at TEXT NOT NULL
      );`,
      `CREATE TABLE IF NOT EXISTS reading_reflections (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        reading_id TEXT NOT NULL,
        reading_date TEXT NOT NULL,
        encrypted_reflection TEXT NOT NULL,
        word_count INTEGER DEFAULT 0,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        sync_status TEXT DEFAULT 'pending',
        supabase_id TEXT,
        UNIQUE(user_id, reading_date),
        FOREIGN KEY (user_id) REFERENCES user_profile(id),
        FOREIGN KEY (reading_id) REFERENCES daily_readings(id)
      );`,
      `CREATE TABLE IF NOT EXISTS schema_migrations (
        version INTEGER PRIMARY KEY,
        applied_at TEXT NOT NULL
      );`,
      `CREATE INDEX IF NOT EXISTS idx_journal_user ON journal_entries(user_id);`,
      `CREATE INDEX IF NOT EXISTS idx_journal_created ON journal_entries(created_at);`,
      `CREATE INDEX IF NOT EXISTS idx_checkin_user ON daily_checkins(user_id);`,
      `CREATE INDEX IF NOT EXISTS idx_checkin_date ON daily_checkins(check_in_date);`,
      `CREATE INDEX IF NOT EXISTS idx_step_user ON step_work(user_id);`,
      `CREATE INDEX IF NOT EXISTS idx_step_number ON step_work(step_number);`,
      `CREATE INDEX IF NOT EXISTS idx_step_supabase_id ON step_work(supabase_id);`,
      `CREATE INDEX IF NOT EXISTS idx_achievement_user ON achievements(user_id);`,
      `CREATE INDEX IF NOT EXISTS idx_sync_queue_table ON sync_queue(table_name);`,
      `CREATE INDEX IF NOT EXISTS idx_daily_readings_day ON daily_readings(day_of_year);`,
      `CREATE INDEX IF NOT EXISTS idx_reading_reflections_user ON reading_reflections(user_id);`,
      `CREATE INDEX IF NOT EXISTS idx_reading_reflections_date ON reading_reflections(reading_date);`,
    ];

    for (const sql of statements) {
      await db.execAsync(sql);
    }

    // Run versioned migrations
    await runMigrations(db);
    logger.info('Database initialization complete', { dbName });
  })();

  initPromises.set(dbName, initPromise);
  try {
    await initPromise;
    initializedDatabases.add(dbName);
  } finally {
    initPromises.delete(dbName);
  }
}

/**
 * Get current schema version from database
 * 
 * @param db - Storage adapter instance
 * @returns Promise resolving to current schema version (0 if no migrations applied)
 * @internal
 */
async function getCurrentSchemaVersion(db: StorageAdapter): Promise<number> {
  try {
    const result = await db.getFirstAsync<{ version: number }>(
      'SELECT MAX(version) as version FROM schema_migrations'
    );
    return result?.version || 0;
  } catch {
    // Table might not exist yet
    return 0;
  }
}

/**
 * Check if a column exists in a table
 * 
 * Used during migrations to safely add columns only if they don't exist.
 * 
 * @param db - Storage adapter instance
 * @param tableName - Name of the table to check
 * @param columnName - Name of the column to check
 * @returns Promise resolving to true if column exists, false otherwise
 * @internal
 */
async function columnExists(
  db: StorageAdapter,
  tableName: string,
  columnName: string
): Promise<boolean> {
  try {
    // SQLite pragma to get table info
    const result = await db.getAllAsync<{ name: string }>(
      `PRAGMA table_info(${tableName})`
    );
    return result.some((col) => col.name === columnName);
  } catch {
    // Table might not exist
    return false;
  }
}

/**
 * Mark a migration as applied
 * 
 * Records the migration version in schema_migrations table.
 * 
 * @param db - Storage adapter instance
 * @param version - Migration version number
 * @internal
 */
async function recordMigration(db: StorageAdapter, version: number): Promise<void> {
  await db.runAsync(
    'INSERT INTO schema_migrations (version, applied_at) VALUES (?, ?)',
    [version, new Date().toISOString()]
  );
}

/**
 * Run all pending migrations
 * 
 * Applies migrations sequentially from current version to CURRENT_SCHEMA_VERSION.
 * Each migration is idempotent and can be safely re-run.
 * 
 * @param db - Storage adapter instance
 * @returns Promise that resolves when all migrations are complete
 * @internal
 */
async function runMigrations(db: StorageAdapter): Promise<void> {
  const currentVersion = await getCurrentSchemaVersion(db);

  logger.info('Database migration check', {
    currentVersion,
    targetVersion: CURRENT_SCHEMA_VERSION,
  });

  if (currentVersion >= CURRENT_SCHEMA_VERSION) {
    logger.info('Database schema is up to date');
    return;
  }

  // Migration version 1: Initial columns for sync and check-ins
  if (currentVersion < 1) {
    logger.info('Running migration v1: Adding sync tracking columns');
    
    // Only add columns if they don't already exist (base schema may have them)
    if (!(await columnExists(db, 'daily_checkins', 'supabase_id'))) {
      try {
        await db.execAsync(`ALTER TABLE daily_checkins ADD COLUMN supabase_id TEXT;`);
      } catch (error) {
        logger.warn('Migration v1: Failed to add daily_checkins.supabase_id', error);
      }
    }
    
    if (!(await columnExists(db, 'daily_checkins', 'updated_at'))) {
      try {
        await db.execAsync(`ALTER TABLE daily_checkins ADD COLUMN updated_at TEXT NOT NULL DEFAULT (datetime('now'));`);
      } catch (error) {
        logger.warn('Migration v1: Failed to add daily_checkins.updated_at', error);
      }
    }
    
    if (!(await columnExists(db, 'sync_queue', 'supabase_id'))) {
      try {
        await db.execAsync(`ALTER TABLE sync_queue ADD COLUMN supabase_id TEXT;`);
      } catch (error) {
        logger.warn('Migration v1: Failed to add sync_queue.supabase_id', error);
      }
    }

    await recordMigration(db, 1);
    logger.info('Migration v1 completed');
  }

  // Migration version 2: Add failed_at for permanent sync failures
  if (currentVersion < 2) {
    logger.info('Running migration v2: Adding failed_at to sync_queue');
    
    if (!(await columnExists(db, 'sync_queue', 'failed_at'))) {
      try {
        await db.execAsync(`ALTER TABLE sync_queue ADD COLUMN failed_at TEXT;`);
      } catch (error) {
        logger.warn('Migration v2: Failed to add sync_queue.failed_at', error);
      }
    }

    await recordMigration(db, 2);
    logger.info('Migration v2 completed');
  }

  // Migration version 3: Add meeting finder tables
  if (currentVersion < 3) {
    logger.info('Running migration v3: Adding meeting finder tables');
    const v3Migrations = [
      // Meeting cache table (public data - no encryption)
      `CREATE TABLE IF NOT EXISTS cached_meetings (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        location TEXT NOT NULL,
        address TEXT NOT NULL,
        city TEXT NOT NULL,
        state TEXT,
        postal_code TEXT,
        country TEXT DEFAULT 'US',
        latitude REAL NOT NULL,
        longitude REAL NOT NULL,
        day_of_week INTEGER,
        time TEXT,
        types TEXT,
        notes TEXT,
        cached_at TEXT NOT NULL,
        cache_region TEXT NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );`,
      // User's favorite meetings (encrypted - sensitive behavioral data)
      `CREATE TABLE IF NOT EXISTS favorite_meetings (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        meeting_id TEXT NOT NULL,
        encrypted_notes TEXT,
        notification_enabled INTEGER DEFAULT 0,
        created_at TEXT NOT NULL,
        sync_status TEXT DEFAULT 'pending',
        supabase_id TEXT,
        UNIQUE(user_id, meeting_id),
        FOREIGN KEY (user_id) REFERENCES user_profile(id),
        FOREIGN KEY (meeting_id) REFERENCES cached_meetings(id)
      );`,
      // Last search location (for offline fallback)
      `CREATE TABLE IF NOT EXISTS meeting_search_cache (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        latitude REAL NOT NULL,
        longitude REAL NOT NULL,
        radius_miles INTEGER DEFAULT 10,
        last_updated TEXT NOT NULL,
        UNIQUE(user_id)
      );`,
      // Indexes for performance
      `CREATE INDEX IF NOT EXISTS idx_cached_meetings_location
        ON cached_meetings(latitude, longitude);`,
      `CREATE INDEX IF NOT EXISTS idx_cached_meetings_day
        ON cached_meetings(day_of_week);`,
      `CREATE INDEX IF NOT EXISTS idx_favorite_meetings_user
        ON favorite_meetings(user_id);`,
    ];

    for (const migration of v3Migrations) {
      try {
        await db.execAsync(migration);
      } catch (error) {
        logger.warn('Migration v3 step failed (may be already applied)', error);
      }
    }

    await recordMigration(db, 3);
    logger.info('Migration v3 completed');
  }

  // Migration version 4: Add supabase_id to step_work for idempotent sync
  if (currentVersion < 4) {
    logger.info('Running migration v4: Adding supabase_id to step_work');
    
    if (!(await columnExists(db, 'step_work', 'supabase_id'))) {
      try {
        await db.execAsync(`ALTER TABLE step_work ADD COLUMN supabase_id TEXT;`);
      } catch (error) {
        logger.warn('Migration v4: Failed to add step_work.supabase_id', error);
      }
    }

    // Index creation is idempotent (IF NOT EXISTS), so safe to run always
    try {
      await db.execAsync(`CREATE INDEX IF NOT EXISTS idx_step_supabase_id ON step_work(supabase_id);`);
    } catch (error) {
      logger.warn('Migration v4: Index creation failed', error);
    }

    await recordMigration(db, 4);
    logger.info('Migration v4 completed');
  }

  // Migration version 5: Add daily readings and reading reflections tables
  if (currentVersion < 5) {
    logger.info('Running migration v5: Adding daily readings and reflections tables');
    const v5Migrations = [
      // Daily readings table (static content, no encryption needed)
      `CREATE TABLE IF NOT EXISTS daily_readings (
        id TEXT PRIMARY KEY,
        day_of_year INTEGER NOT NULL UNIQUE CHECK(day_of_year >= 1 AND day_of_year <= 366),
        month INTEGER NOT NULL CHECK(month >= 1 AND month <= 12),
        day INTEGER NOT NULL CHECK(day >= 1 AND day <= 31),
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        source TEXT NOT NULL,
        reflection_prompt TEXT NOT NULL,
        created_at TEXT NOT NULL
      );`,
      // Reading reflections table (user-generated content, encrypted)
      `CREATE TABLE IF NOT EXISTS reading_reflections (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        reading_id TEXT NOT NULL,
        reading_date TEXT NOT NULL,
        encrypted_reflection TEXT NOT NULL,
        word_count INTEGER DEFAULT 0,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        sync_status TEXT DEFAULT 'pending',
        supabase_id TEXT,
        UNIQUE(user_id, reading_date),
        FOREIGN KEY (user_id) REFERENCES user_profile(id),
        FOREIGN KEY (reading_id) REFERENCES daily_readings(id)
      );`,
      // Indexes for performance
      `CREATE INDEX IF NOT EXISTS idx_daily_readings_day ON daily_readings(day_of_year);`,
      `CREATE INDEX IF NOT EXISTS idx_reading_reflections_user ON reading_reflections(user_id);`,
      `CREATE INDEX IF NOT EXISTS idx_reading_reflections_date ON reading_reflections(reading_date);`,
    ];

    for (const migration of v5Migrations) {
      try {
        await db.execAsync(migration);
      } catch (error) {
        logger.warn('Migration v5 step failed (may be already applied)', error);
      }
    }

    await recordMigration(db, 5);
    logger.info('Migration v5 completed');
  }

  // Migration version 6: Add gratitude field to daily_checkins
  if (currentVersion < 6) {
    logger.info('Running migration v6: Adding gratitude field to daily_checkins');

    if (!(await columnExists(db, 'daily_checkins', 'encrypted_gratitude'))) {
      try {
        await db.execAsync(`ALTER TABLE daily_checkins ADD COLUMN encrypted_gratitude TEXT;`);
      } catch (error) {
        logger.warn('Migration v6: Failed to add daily_checkins.encrypted_gratitude', error);
      }
    }

    await recordMigration(db, 6);
    logger.info('Migration v6 completed');
  }

  logger.info('All migrations completed', { newVersion: CURRENT_SCHEMA_VERSION });
}

/**
 * Clear all local data
 * 
 * **Warning**: This permanently deletes all user data from the local database!
 * Only call this during logout or account deletion. Encryption keys should
 * be deleted separately using `deleteEncryptionKey()`.
 * 
 * @param db - Storage adapter instance
 * @returns Promise that resolves when all data is cleared
 * @example
 * ```ts
 * // During logout
 * await clearDatabase(db);
 * await deleteEncryptionKey();
 * ```
 */
export async function clearDatabase(db: StorageAdapter): Promise<void> {
  await db.execAsync(`
    DELETE FROM sync_queue;
    DELETE FROM favorite_meetings;
    DELETE FROM meeting_search_cache;
    DELETE FROM cached_meetings;
    DELETE FROM reading_reflections;
    DELETE FROM daily_readings;
    DELETE FROM achievements;
    DELETE FROM step_work;
    DELETE FROM daily_checkins;
    DELETE FROM journal_entries;
    DELETE FROM user_profile;
  `);
}
